Al leer los requerimientos referidos a distintos formatos de fechas, lo primero que pensé fue en que era necesario utilizar expresiones regulares (Regular Expressions o "RegExp"), debido a que son bastante útiles a la hora de trabajar con patrones en texto; por lo que basé primero en armar las regexp necesarias que machee con los formatos de fecha solicitados.

Al principio, opté por crear una clase "DateHelper" para que se encargue tanto de machear el patrón del String (ISO8601, Latinoamericano o Norteamericano) como la de parsear dicho String a Date. El problema que me dió esto fue que en primer lugar, le estaba dando demasiada responsabilidad al DateHelper y segundo lugar, habían muchos métodos repetidos para cada formato de fecha (y encima tenían parámetros innecesarios). Es por eso que cree una clase abstracta llamada "DatePattern", la cual se encargaría de realizar los parseos de String a Date (delegar de responsabilidades), por lo que el DateHelper sólo se limitaría a decidir a qué formato de fecha machea el String.

De la clase abstracta "DatePattern", heredan tres clases: "ISO8601", "LatinAmerican" y "NorthAmerican". En los constructores de dichas clases, se definen el formato de fecha y, por otro lado, implementa un método para formatear el String antes de parsear el String. De esta manera, y aprovechando el polimormiso del DatePattern, en la clase DateHelper utilizamos la clase abstracta para hacer los parseos necesarios según el formato de fecha deseado (o que al menos coincide).